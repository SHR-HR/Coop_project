// Импорт функций createAsyncThunk и createSlice из Redux Toolkit для создания асинхронных действий и срезов состояния
import { createAsyncThunk, createSlice } from "@reduxjs/toolkit";
// Импорт API объекта для выполнения запросов к серверу
import { api } from "../../api/api.ts";
// Импорт типа User из файла с типами для типизации данных пользователей
import type { User } from "../../shared/types/types";
// Импорт типа RootState для типизации состояния всего хранилища
import type { RootState } from "../store";

// Определение интерфейса для состояния пользователей
interface UsersState {
    // Массив пользователей системы
    users: User[];
    // Флаг, указывающий выполняется ли в данный момент запрос
    loading: boolean;
    // Сообщение об ошибке или null если ошибок нет
    error: string | null;
}

// Начальное состояние для среза пользователей
const initialState: UsersState = {
    // Пустой массив пользователей по умолчанию
    users: [],
    // Загрузка не выполняется по умолчанию
    loading: false,
    // Ошибок нет по умолчанию
    error: null,
};

// Создание асинхронного действия для получения списка пользователей
// Дженерик параметры:
// - первый: тип возвращаемого значения при успехе (User[] - массив пользователей)
// - второй: тип аргументов (void - без аргументов)
// - третий: тип конфигурации с state: RootState и rejectValue: string
export const fetchUsers = createAsyncThunk<
    User[],
    void,
    { state: RootState; rejectValue: string }
>
    // Название действия и асинхронная функция-исполнитель
    ("users/fetchUsers", async (_, { getState, rejectWithValue }) => {
        // Получение состояния аутентификации из глобального состояния
        const { username, password, isAuthenticated } = getState().auth;

        // Блок try для обработки успешного выполнения
        try {
            // Вызов API метода для получения списка пользователей с передачей учетных данных если пользователь аутентифицирован
            const data = await api.usersApi.getUsers(
                isAuthenticated ? { username, password } : undefined
            );
            // Возврат полученного массива пользователей
            return data;
            // Блок catch для обработки ошибок
        } catch (error: any) {
            // Получение статуса ошибки из ответа сервера
            const status = error?.response?.status;
            // Проверка если статус ошибки 401 (неавторизован)
            if (status === 401) {
                // Возврат ошибки с сообщением о необходимости авторизации
                return rejectWithValue("Доступ запрещён: войдите в систему");
            }
            // Возврат детали ошибки из ответа сервера или общего сообщения об ошибке
            return rejectWithValue(
                error?.response?.data?.detail || "Ошибка загрузки пользователей"
            );
        }
    });

// Создание среза (slice) для управления состоянием пользователей
export const usersSlice = createSlice({
    // Уникальное имя среза
    name: "users",
    // Начальное состояние
    initialState,
    // Синхронные редюсеры (редюсеры для синхронных действий)
    reducers: {
        // Редюсер для очистки ошибок
        clearError: (state) => {
            // Очистка сообщения об ошибке
            state.error = null;
        },
    },
    // Дополнительные редюсеры для обработки асинхронных действий
    extraReducers: (builder) => {
        // Использование builder для цепочного добавления обработчиков
        builder
            // Обработчик для состояния pending (запрос выполняется) действия fetchUsers
            .addCase(fetchUsers.pending, (state) => {
                // Установка флага загрузки в true
                state.loading = true;
                // Очистка предыдущих ошибок
                state.error = null;
            })
            // Обработчик для состояния fulfilled (запрос успешно завершен) действия fetchUsers
            .addCase(fetchUsers.fulfilled, (state, action) => {
                // Сброс флага загрузки
                state.loading = false;
                // Сохранение полученного массива пользователей в состояние
                state.users = action.payload;
            })
            // Обработчик для состояния rejected (запрос завершен с ошибкой) действия fetchUsers
            .addCase(fetchUsers.rejected, (state, action) => {
                // Сброс флага загрузки
                state.loading = false;
                // Сохранение ошибки из payload или использование сообщения по умолчанию
                state.error = (action.payload as string) ?? "Неизвестная ошибка";
            });
    },
});

// Экспорт синхронных действий (action creators)
export const { clearError } = usersSlice.actions;

// Селекторы для доступа к данным из состояния пользователей

// Селектор для получения массива всех пользователей
export const selectAllUsers = (state: RootState) => state.users.users;

// Селектор для получения флага загрузки пользователей
export const selectUsersLoading = (state: RootState) => state.users.loading;

// Селектор для получения ошибки пользователей
export const selectUsersError = (state: RootState) => state.users.error;


/* ===== ПОЯСНЕНИЯ К КОММЕНТАРИЯМ ===== */

/*
1. Интерфейс состояния пользователей:
   - users: User[] - массив объектов User, представляющих пользователей системы
   - loading: boolean - индикатор выполнения запроса загрузки пользователей
   - error: string | null - сообщение об ошибке для отображения в пользовательском интерфейсе

2. Начальное состояние:
   - users: [] - пустой массив, так как изначально пользователи не загружены
   - loading: false - отсутствие активных запросов при инициализации
   - error: null - отсутствие ошибок при старте приложения

3. Асинхронное действие fetchUsers:
   - Не принимает аргументов (использует _ для обозначения отсутствия параметров)
   - Использует getState для доступа к состоянию аутентификации
   - Выполняет проверку аутентификации перед вызовом API

4. Логика аутентификации в fetchUsers:
   - Получение username, password, isAuthenticated из состояния auth
   - Передача учетных данных в API только если isAuthenticated = true
   - Обработка ошибки 401 с соответствующим сообщением на русском языке

5. Обработка ошибок в fetchUsers:
   - Проверка статуса ошибки 401 для специфичного сообщения о необходимости авторизации
   - Использование error?.response?.data?.detail для детализированных сообщений от сервера
   - Fallback сообщение "Ошибка загрузки пользователей" на русском языке

6. Структура среза usersSlice:
   - name: "users" - идентификатор для Redux DevTools и отладки
   - initialState - начальное состояние с пустым массивом пользователей
   - reducers - только clearError для ручной очистки ошибок
   - extraReducers - обработка асинхронного действия fetchUsers

7. Обработка состояний в extraReducers:
   - fetchUsers.pending: установка loading в true и очистка предыдущих ошибок
   - fetchUsers.fulfilled: сброс loading и сохранение загруженных пользователей
   - fetchUsers.rejected: сброс loading и сохранение ошибки

8. Управление состоянием загрузки:
   - loading устанавливается в true при начале запроса
   - Сбрасывается в false при завершении (успешном или с ошибкой)
   - Позволяет показывать индикаторы загрузки в пользовательском интерфейсе

9. Обновление состояния при успешной загрузке:
   - state.users = action.payload - полная замена массива пользователей
   - Новые данные полностью заменяют старые (не добавление, а замена)
   - Обеспечивает актуальность данных пользователей

10. Обработка ошибок в rejected состоянии:
    - action.payload as string - приведение типа для TypeScript
    - ?? "Неизвестная ошибка" - оператор нулевого слияния для fallback сообщения
    - Сохранение ошибки для отображения пользователю

11. Селекторы:
    - selectAllUsers - получение массива всех пользователей
    - selectUsersLoading - получение флага загрузки
    - selectUsersError - получение сообщения об ошибке
    - Все селекторы типизированы с RootState для безопасности типов

12. Особенности безопасности:
    - Проверка аутентификации перед загрузкой списка пользователей
    - Сообщения об ошибках на русском языке для лучшего пользовательского опыта
    - Обработка различных типов ошибок (сетевые, авторизации, серверные)

13. Архитектурные решения:
    - Простой срез с одной основной операцией (загрузка пользователей)
    - Четкое разделение синхронных и асинхронных действий
    - Централизованная обработка ошибок

14. Использование в приложении:
    - Для отображения списка пользователей в административных разделах
    - Для выбора пользователей при назначении задач
    - Для отображения информации о команде или участниках проекта

15. Оптимизация:
    - Однократная загрузка пользователей при необходимости
    - Локальное кэширование данных в состоянии Redux
    - Минимальные изменения состояния при обновлении
*/