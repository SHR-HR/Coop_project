// Импорт хуков из React для работы с состоянием, эффектами и мемоизацией
import { useEffect, useMemo, useState } from "react";
// Импорт файла стилей для компонента WeeklyDelta из SCSS модуля
import s from "./WeeklyDelta.module.scss";
// Импорт хука useSelector из React Redux для доступа к состоянию хранилища
import { useSelector } from "react-redux";
// Импорт селектора для получения глобальных итоговых показателей
import { selectGlobalTotals } from "../../../store/selectors/statisticsSelectors";

/** Псевдо-аналитика "за неделю" - тип для хранения снимков статистики */
// Тип Totals определяет структуру данных для хранения статистики задач
type Totals = { completed: number; inWork: number; failed: number };

// Ключ для хранения снимка статистики в localStorage
// "dashboard:lastSnapshot" - уникальный идентификатор для данных предыдущего снимка
const LS_KEY = "dashboard:lastSnapshot";

// Функция для чтения предыдущего снимка статистики из localStorage
function readSnapshot(): Totals | null {
    try {
        // Получение сырых данных из localStorage по ключу LS_KEY
        const raw = localStorage.getItem(LS_KEY);
        // Если данные существуют, парсим JSON, иначе возвращаем null
        return raw ? (JSON.parse(raw) as Totals) : null;
    } catch (e) {
        // Обработка ошибок парсинга или доступа к localStorage
        // void e - игнорируем ошибку, но помечаем переменную как использованную для ESLint
        // (eslint) помечаем переменную как «использованную»
        void e;
        return null;
    }
}

// Функция для сохранения текущего снимка статистики в localStorage
function saveSnapshot(t: Totals) {
    try {
        // Преобразование объекта в JSON строку и сохранение в localStorage
        localStorage.setItem(LS_KEY, JSON.stringify(t));
    } catch (e) {
        // Обработка ошибок записи в localStorage
        // void e - игнорируем ошибку, но помечаем переменную как использованную для ESLint
        // (eslint) помечаем переменную как «использованную»
        void e;
    }
}

// Экспорт компонента WeeklyDelta по умолчанию
// Компонент для отображения изменения статистики с предыдущего визита пользователя
export default function WeeklyDelta() {
    // Получение текущих глобальных итогов из Redux хранилища
    const totals = useSelector(selectGlobalTotals);
    // Состояние для хранения предыдущего снимка статистики
    // useState с типом Totals | null - может быть объектом или null
    const [prev, setPrev] = useState<Totals | null>(null);

    // Эффект для загрузки предыдущего снимка при монтировании компонента
    useEffect(() => {
        // Загрузка предыдущего снимка из localStorage и установка в состояние
        setPrev(readSnapshot());
        // Установка таймера для сохранения текущего снимка с задержкой 300ms
        // Задержка предотвращает частое сохранение при быстрых изменениях
        const t = window.setTimeout(() => saveSnapshot(totals), 300);
        // Функция очистки эффекта - отмена таймера при размонтировании компонента
        return () => window.clearTimeout(t);
        //// eslint-disable-next-line react-hooks/exhaustive-deps
        // Пустой массив зависимостей означает что эффект выполнится только при монтировании
    }, []);

    // Мемоизированное вычисление разницы между текущей и предыдущей статистикой
    const diff = useMemo(() => {
        // Если предыдущего снимка нет, возвращаем null
        if (!prev) return null;
        // Вычисление разницы по каждому показателю
        return {
            completed: totals.completed - prev.completed,  // Разница выполненных задач
            inWork: totals.inWork - prev.inWork,          // Разница задач в работе
            failed: totals.failed - prev.failed,          // Разница просроченных задач
        };
        //// eslint-disable-next-line react-hooks/exhaustive-deps
        // Зависимости: prev и отдельные поля totals (оптимизация производительности)
    }, [prev, totals.completed, totals.inWork, totals.failed]);

    // Возвращение JSX разметки компонента
    return (
        // Семантический HTML тег section для группировки связанного контента
        // aria-label обеспечивает доступность для скринридеров
        <section className={s.wrap} aria-label="Динамика за неделю">
            {/* Заголовок третьего уровня для секции */}
            <h3 className={s.title}>Динамика (с последнего визита)</h3>
            {/* Список для отображения изменений по каждому показателю */}
            <ul className={s.row}>
                {/* Элемент списка для выполненных задач */}
                <li className={s.item}>
                    {/* Метка "Выполнено" */}
                    <span className={s.k}>Выполнено</span>
                    {/* Значение изменения с условными классами для стилизации */}
                    {/* className формируется динамически на основе знака изменения */}
                    <b className={`${s.v} ${diff && diff.completed >= 0 ? s.up : s.down}`}>
                        {/* Отображение значения изменения или прочерка если данных нет */}
                        {diff ? signed(diff.completed) : "—"}
                    </b>
                </li>
                {/* Элемент списка для задач в работе */}
                <li className={s.item}>
                    {/* Метка "В работе" */}
                    <span className={s.k}>В работе</span>
                    {/* Значение изменения с условными классами */}
                    <b className={`${s.v} ${diff && diff.inWork >= 0 ? s.up : s.down}`}>
                        {diff ? signed(diff.inWork) : "—"}
                    </b>
                </li>
                {/* Элемент списка для просроченных задач */}
                <li className={s.item}>
                    {/* Метка "Просрочено" */}
                    <span className={s.k}>Просрочено</span>
                    {/* Для просроченных задач логика инвертирована: уменьшение - хорошо */}
                    <b className={`${s.v} ${diff && diff.failed >= 0 ? s.down : s.up}`}>
                        {diff ? signed(diff.failed) : "—"}
                    </b>
                </li>
            </ul>
            {/* Подсказка с объяснением принципа работы компонента */}
            <span className={s.hint}>
                Сравнение с прошлым сохранённым срезом. Срез обновляется при каждом визите.
            </span>
        </section>
    );
}

// Вспомогательная функция для форматирования чисел со знаком
function signed(n: number) {
    if (n > 0) return `+${n}`;  // Положительные числа с плюсом
    if (n < 0) return `${n}`;   // Отрицательные числа с минусом (уже есть)
    return "0";                 // Ноль без знака
}





// =====================================================
// ПОЯСНЕНИЯ К КОММЕНТАРИЯМ В КОДЕ:
// =====================================================

// 1. НАЗНАЧЕНИЕ КОМПОНЕНТА:
//    - Отображение изменений статистики с предыдущего визита пользователя
//    - "Псевдо-аналитика" - имитирует анализ трендов за неделю
//    - Показывает прогресс/регресс по ключевым показателям

// 2. МЕХАНИЗМ РАБОТЫ:
//    - При первом визите: сохраняет текущую статистику как базовую
//    - При последующих визитах: сравнивает текущую статистику с сохраненной
//    - Показывает разницу (дельту) по каждому показателю

// 3. РАБОТА С LOCALSTORAGE:
//    - readSnapshot: безопасное чтение с обработкой ошибок
//    - saveSnapshot: безопасная запись с обработкой ошибок
//    - try-catch блоки защищают приложение от сбоев

// 4. ТАЙМИНГ И ОПТИМИЗАЦИЯ:
//    - Задержка 300ms перед сохранением предотвращает частое обновление
//    - useMemo предотвращает лишние вычисления разницы
//    - Очистка таймера предотвращает утечки памяти

// 5. ЛОГИКА ОТОБРАЖЕНИЯ ИЗМЕНЕНИЙ:
//    - completed: увеличение = хорошо (зеленый), уменьшение = плохо (красный)
//    - inWork: увеличение = хорошо (зеленый), уменьшение = плохо (красный)
//    - failed: увеличение = плохо (красный), уменьшение = хорошо (зеленый) - инвертированная логика

// 6. ОБРАБОТКА ГРАНИЧНЫХ СЛУЧАЕВ:
//    - Защита от отсутствия предыдущих данных (diff === null)
//    - Отображение прочерка "—" когда данных для сравнения нет
//    - Обработка ошибок localStorage без падения приложения

// 7. ДОСТУПНОСТЬ И UX:
//    - aria-label для скринридеров
//    - Подсказка с объяснением принципа работы
//    - Четкая визуальная индикация положительных/отрицательных изменений
//    - Семантическая разметка улучшает понимание структуры

// 8. TypeScript ТИПИЗАЦИЯ:
//    - Totals тип для строгой типизации статистики
//    - Totals | null для обработки отсутствия данных
//    - Явные типы для параметров и возвращаемых значений

// 9. ПРОИЗВОДИТЕЛЬНОСТЬ:
//    - useMemo оптимизирует вычисление разницы
//    - Селективные зависимости useMemo (отдельные поля totals)
//    - Минимальное взаимодействие с localStorage

// 10. ПОЛЬЗОВАТЕЛЬСКАЯ ЦЕННОСТЬ:
//     - Позволяет видеть прогресс между визитами
//     - Мотивирует к улучшению показателей
//     - Дает контекст для текущего состояния статистики
//     - Простое и интуитивно понятное отображение изменений