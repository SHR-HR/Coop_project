// Импорт хуков из React для работы с побочными эффектами и мемоизацией
import { useEffect, useMemo } from "react";
// Импорт хука useSelector из React Redux для доступа к состоянию хранилища
import { useSelector } from "react-redux";
// Импорт селектора для получения глобальных итоговых показателей
import { selectGlobalTotals } from "../../../store/selectors/statisticsSelectors";

// Определение типа Point для точек данных в истории
// Каждая точка содержит временную метку и три показателя
type Point = {
    ts: number;        // Временная метка (timestamp) в миллисекундах
    completed: number; // Количество выполненных задач на момент записи
    inWork: number;    // Количество задач в работе на момент записи
    failed: number;    // Количество просроченных задач на момент записи
};

// Ключ для хранения данных в localStorage
// "dashboard:history:v1" - уникальный идентификатор с версией для совместимости
const LS_KEY = "dashboard:history:v1";

// Максимальное количество точек данных для хранения в истории
// LIMIT = 20 - ограничивает размер истории для предотвращения переполнения
const LIMIT = 20;

// Функция для чтения данных истории из localStorage
function read(): Point[] {
    try {
        // Получение сырых данных из localStorage по ключу LS_KEY
        const raw = localStorage.getItem(LS_KEY);
        // Если данные существуют, парсим JSON, иначе возвращаем пустой массив
        return raw ? (JSON.parse(raw) as Point[]) : [];
    } catch {
        // В случае ошибки парсинга или доступа возвращаем пустой массив
        return [];
    }
}

// Функция для записи данных истории в localStorage
function write(arr: Point[]) {
    try {
        // Преобразование массива в JSON строку и сохранение в localStorage
        localStorage.setItem(LS_KEY, JSON.stringify(arr));
        // eslint-disable-next-line no-empty
        // Пустой блок catch - ошибки игнорируются для предотвращения сбоев приложения
    } catch { }
}

/**
 * Пользовательский хук useDashboardHistory
 * Сохраняет текущие totals в историю (1 запись на визит) и возвращает массив Point[]
 * Хук обеспечивает сохранение истории изменений показателей дашборда
 */
export function useDashboardHistory() {
    // Получение текущих глобальных показателей из Redux хранилища
    const totals = useSelector(selectGlobalTotals);

    // Эффект для сохранения данных в историю при изменении показателей
    useEffect(() => {
        // Установка таймера с небольшой задержкой для предотвращения мигания при загрузке
        // 200ms задержка обеспечивает плавное обновление без резких изменений
        const t = window.setTimeout(() => {
            // Создание новой точки данных с текущими показателями
            const now: Point = {
                ts: Date.now(),              // Текущее время в миллисекундах
                completed: totals.completed, // Текущее количество выполненных задач
                inWork: totals.inWork,       // Текущее количество задач в работе
                failed: totals.failed,       // Текущее количество просроченных задач
            };

            // Чтение предыдущей истории из localStorage
            const prev = read();

            // Получение последней точки из предыдущей истории
            const last = prev[prev.length - 1];

            // Проверка на необходимость добавления новой точки
            // Новая точка добавляется если:
            // - История пустая (!last) ИЛИ
            // - Любой из показателей изменился
            if (
                !last ||
                last.completed !== now.completed ||
                last.inWork !== now.inWork ||
                last.failed !== now.failed
            ) {
                // Создание нового массива: добавляем новую точку и обрезаем до LIMIT
                // [...prev, now] - создаем новый массив с добавлением новой точки
                // .slice(-LIMIT) - оставляем только последние LIMIT элементов
                const next = [...prev, now].slice(-LIMIT);

                // Сохранение обновленной истории в localStorage
                write(next);
            }
        }, 200);

        // Функция очистки эффекта - отмена таймера при размонтировании или изменении зависимостей
        return () => window.clearTimeout(t);

        // Массив зависимостей эффекта - срабатывает при изменении любого из показателей
    }, [totals.completed, totals.inWork, totals.failed]);

    // Мемоизация прочитанной истории для предотвращения лишних чтений
    // useMemo возвращает историю только при первом рендере, не пересчитывая при каждом
    const history = useMemo(() => read(), []);

    // Возвращение массива точек истории
    return history;
}




// =====================================================
// ПОЯСНЕНИЯ К КОММЕНТАРИЯМ В КОДЕ:
// =====================================================

// 1. НАЗНАЧЕНИЕ ХУКА:
//    - Сохранение истории изменений показателей дашборда между сессиями
//    - Предоставление исторических данных для построения графиков трендов
//    - Обеспечение персистентности данных через localStorage

// 2. СТРУКТУРА ДАННЫХ:
//    - Point - интерфейс для одной точки данных с timestamp и тремя показателями
//    - LS_KEY - уникальный ключ для идентификации данных в localStorage
//    - LIMIT = 20 - ограничение размера истории для производительности

// 3. РАБОТА С LOCALSTORAGE:
//    - read() - безопасное чтение с обработкой ошибок парсинга
//    - write() - безопасная запись с игнорированием ошибок
//    - try-catch блоки защищают приложение от сбоев при проблемах с localStorage

// 4. ЛОГИКА СОХРАНЕНИЯ:
//    - Задержка 200ms предотвращает частое сохранение при быстрых изменениях
//    - Проверка на дубликаты избегает сохранения одинаковых точек подряд
//    - .slice(-LIMIT) поддерживает фиксированный размер истории

// 5. ОПТИМИЗАЦИЯ ПРОИЗВОДИТЕЛЬНОСТИ:
//    - useMemo для истории предотвращает лишние чтения из localStorage
//    - Зависимости useEffect только от изменяющихся показателей
//    - Очистка таймера предотвращает утечки памяти

// 6. ОБРАБОТКА ГРАНИЧНЫХ СЛУЧАЕВ:
//    - Пустой массив при ошибке чтения localStorage
//    - Игнорирование ошибок записи для стабильности приложения
//    - Проверка на существование последней точки (!last)

// 7. ПОЛЬЗОВАТЕЛЬСКИЙ ОПЫТ:
//    - Задержка сохранения обеспечивает плавность интерфейса
//    - Сохранение только измененных данных экономит пространство
//    - Ограничение истории предотвращает замедление работы

// 8. ARCHITECTURE PATTERNS:
//    - Custom Hook инкапсулирует логику работы с историей
//    - Separation of Concerns: чтение/запись вынесены в отдельные функции
//    - Immutable Updates: создание новых массивов вместо мутаций